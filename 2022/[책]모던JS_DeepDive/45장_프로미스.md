# 45장 프로미스

비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.  
하지만 콜백 함수에는 많은 단점들이 존재하고, 이를 해결하기 위해 ES6에서는 비동기 처리를 위해 프로미스를 도입했다. 

## 45.1 비동기 처리를 위한 콜백 패턴의 단점
1. 콜백헬
  ```js
  const get = (url, callback) => {
    const xhr = new XMLHttpRequest() // xhr 객체 생성
    xhr.open("GET", url) // HTTP 초기화
    xhr.send() // HTTP 전송

    // onload 이벤트 핸들러는 응답이 온 경우에 실행
    xhr.onload = () => {
      if (xhr.status === 200) {
        callback(JSON.parse(xhr.response))
      } else {
        console.error(xhr.status)
      }
    }
  }

  get(`https://getmyinfo.com/posts/1`, (data) => {
    const userId = data.userId // 받은 data의 userId
    console.log(userId)
    // post에서 가져온 userId를 이용해서 user정보를 획득
    get(`https://getmyinfo.com/users/${userId}`,
        (userInfo) => {
      console.log(userInfo)
    })
  })
  ```
  - 처음 posts/1에서 Id를 이용해서 정보 가져오고, 그 가져온 정보 안에서 userId를 가지고 또 user의 정보를 가져오는 요청을 한 것이다.  
    실행되는 함수를 보면 get이라는 비동기 함수 안에 또 get이라는 비동기 함수가 있다.  
    여기서 안에 있는 get 함수는 첫번째 요청이 성공했을 경우에만 동작하는 콜백 함수인 것이다(인자로 전달).  
    벌써부터 **가독성이 좋지 않고, 실수를 유발하는 경우가 많아진다. 또한 디버깅이 쉽지 않다.**  

2. 에러 처리의 한계
  - `try-catch`문으로 애러를 알려주는 코드를 작성했다.
    ```js
    try{
      setTimeout(()=>{throw new Error('error')},100) // 비동기메서드
    }catch(e){
      console.error(e)
    }
    ```
    이를 실행시켜보면 애러가 캐치되지 않는다.
    `setTimeout`이 호출되면 실행 컨텍스트가 콜스택에 푸시되고 바로 실행되서 제거가 된다. 
    이는 setTimeout이 비동기함수이기 때문이다.  
    이후 타이머가 끝나면 setTimeout이 태스크퓨로 푸시되고 콜스택이 빈 후에 콜스택으로 푸시되어 실행된다.  
    따라서 콜백함수가 발생시킨 에러는 catch 블록에서 캐치되지 않는다.

## 45.2 프로미스 생성
## 45.3 프로미스의 후속 처리 메서드
## 45.4 프로미스의 에러 처리
## 45.5 프로미스 체이닝
## 45.6 프로미스의 정적 메서드
## 45.7 마이크로태스크 큐
## 45.8 fetch